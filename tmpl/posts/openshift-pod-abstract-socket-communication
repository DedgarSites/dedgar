<!DOCTYPE html>
<html lang="en">
{{template "header.html"}}
{{template "navbar.html"}}
<head>
    <title>abstract sockets</title>
</head>
<body>
<div class="w3-content" style="max-width:900px;margin-top:75px">
 <p>
Abstract sockets are a great way for multiple containers in the same OpenShift or Kubernetes pod to communicate with each other, without using any additional storage volumes or network configuration. Since all the containers in a single OpenShift and Kubernetes pod will share the same IPC namespace by default, you can reference a Unix Domain Socket in your program like '@my-abstract-socket', without having to create and keep track of mounth paths.

&nbsp;

<!--more-->

<hr />
Some practical examples first, with additional details to follow:

Golang - Listening
<pre>
</pre>

Golang - Connecting
<pre>
</pre>

Python - Listening
<pre>
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

server_address = (hostname, int(hostport))
#sock.bind(server_address)
sock.bind('\0MyBindName')

sock.listen(1)
</pre>

Python - Connecting
<pre>
import psutil

mylist = psutil.net_connections(kind='unix')

print(mylist)

  [sconn(fd=3, family=<AddressFamily.AF_UNIX: 1>, type=1, laddr='@MyBindName', raddr=None, status='NONE', pid=10974)]

# TCP psutil output
inetlist = psutil.net_connections(kind='inet')
print(inetlist)
  [sconn(fd=3, family=<AddressFamily.AF_INET: 2>, type=<SocketKind.SOCK_STREAM: 1>, laddr=('127.0.0.1', 8080), raddr=(), status='LISTEN', pid=10982)]
</pre>

Abstract sockets on Linux function the same way as other Unix Domain Sockets, except they don't have a filepath associated with them. Instead, you access them via the '@' symbol. For example, /var/run/crio/crio.sock is the socket file associated with the cri-o Container Runtime Interface, and we would access it from our own programs using that file path. Wheras we might create an abstract socket called 'example.sock' and access it by referring to '@example.sock'; No path needed. Note that it doesn't require a '.sock' extension, it's just to keep up with convention. 


<ul>
  <li>No need to keep track of another container's socket mount path.</li>
  <li>Better performance potential and less overhead than TCP socket communication.</li>
  <li>No need to make sure a directory exists and is shared properly with other components or users.</li>
  <li>No directory permissions or SELinux context to manage. This is less of an issue in containerized workloads, however.</li>
</ul>

They are super useful for container to container communication. They automatically clean themselves up: the socket no longer appears in the abstract socket namespace when its parent process is no longer running

Access a file using a privileged container, and send its file descriptor to another less privileged container for processing. Abstract sockets work with the same sendmsg() and recvmsg() system calls that you would use in a program that listens on a standard socket.


When wouldn't we want to use abstract sockets?
<ul>
  <li>Maybe you have multiple containers in the same pod, and you really don't want all of them to have potential access to your socket. In that case, providing a socket file through a shared volume would provide better isolation.</li>
  <li> Many programs have been written to only accept file paths as their acceptable socket formats, and don't even give you the option to refer to something in the abstract socket namespace. 
  <li>Also, if you're not communicating with any other process on the same physical or virtual host, you won't get much value from having something visable to other containers on the same host</li>
</ul>
 </p>
</div>
</body>
{{template "footer.html"}}
</html>

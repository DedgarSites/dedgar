<!DOCTYPE html>
<html lang="en">
{{template "header.html"}}
{{template "navbar.html"}}
<head>
    <title>abstract sockets</title>
</head>
<body>
<div class="w3-content" style="max-width:900px;margin-top:75px">
 <p>
Abstract sockets are a great way for multiple containers in the same OpenShift or Kubernetes pod to communicate with each other, without using any additional storage volumes or network configuration. Since you can reference the socket in your program like '@my-abstract-socket', you don't have to keep track of mounth paths.

&nbsp;

<!--more-->

<hr />
Some practical examples first, with additional details to follow:

Golang
<pre>
package main

import (
	"fmt"
	"net/rpc"
)

func main() {
	var data []byte // can be a go datatype like a stuct, whatever the RPC server accepts
	var reply []byte

	client, err := rpc.DialHTTP("unix", "@my-abstract-socket.sock")
	if err != nil {
		fmt.Println("Error dialing socket:", err)
	}

	err = client.Call("someRPCFunctionName", data, &reply)
	if err != nil {
		fmt.Println("Error calling the RPC server's function:", err)
	}

	if len(reply) > 0 {
		fmt.Println("A reply was returned")
	} else {
		fmt.Println("The reply was empty")
	}
	fmt.Println(string(reply[:]))
}
</pre>

Python - Listening
<pre>
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

server_address = (hostname, int(hostport))
#sock.bind(server_address)
sock.bind('\0MyBindName')

sock.listen(1)
</pre>

Python - Connecting
<pre>
import psutil

mylist = psutil.net_connections(kind='unix')

print(mylist)

  [sconn(fd=3, family=<AddressFamily.AF_UNIX: 1>, type=1, laddr='@MyBindName', raddr=None, status='NONE', pid=10974)]

# TCP psutil output
inetlist = psutil.net_connections(kind='inet')
print(inetlist)
  [sconn(fd=3, family=<AddressFamily.AF_INET: 2>, type=<SocketKind.SOCK_STREAM: 1>, laddr=('127.0.0.1', 8080), raddr=(), status='LISTEN', pid=10982)]
</pre>

Abstract sockets on Linux function the same way as other Unix Domain Sockets, except they don't have a filepath associated with them. Instead, you access them via the '@' symbol. For example, /var/run/crio/crio.sock is the socket file associated with the cri-o Container Runtime Interface, and we would access it from our own programs using that file path. Wheras we might create an abstract socket called 'example.sock' and access it by referring to '@example.sock'; No path needed. Note that it doesn't require a '.sock' extension, we're just keeping up with convention. 


<ul>
  <li>No need to keep track of another container's socket mount path.</li>
  <li>Better performance potential and less overhead than TCP socket communication</li>
  <li></li>
  <li></li>
</ul>

They are super useful for container to container communication. They automatically clean themselves up: the socket no longer appears in the abstract socket namespace when its parent process is no longer running

Access a file using a privileged container, and send its file descriptor to another less privileged container for processing. Abstract sockets work with the same sendmsg() and recvmsg() system calls that you would use in a program that listens on a standard socket.


When wouldn't we want to use abstract sockets?
<ul>
  <li>Maybe you have multiple containers in the same pod, and you really don't want all of them to have potential access to your socket. In that case, providing a socket file through a shared volume would provide better isolation.</li>
  <li> Many programs have been written to only accept file paths as their acceptable socket formats, and don't even give you the option to refer to something in the abstract socket namespace. 
  <li>Also, if you're not communicating with any other process on the same physical or virtual host, you won't get much value from having something visable to other containers on the same host</li>
</ul>
 </p>
</div>
</body>
{{template "footer.html"}}
</html>
